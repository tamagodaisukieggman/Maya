//===============================================
//
// Vegetation Normal Smooth
//
//===============================================

/////////////////////////////////////////////////
// メイン
/////////////////////////////////////////////////
global proc shr_vegetationNormalSmooth()
{
    source "shr_rebuildHdaOutputMeshes";

    // ツールログ送信
    shr_toolLog("Vegetation Normal Smooth", "", "launched.");

    // Houdini 環境が有効か
    int $houdiniEngineEnabled = python("import shr.utils.hda_loader.houdini_util as houdini_util; houdini_util.main()");

    if (`window -exists uWnd_shr_vegetationNromalSmooth` == 1)
    {
        // NOTE:
        return;
        // deleteUI uWnd_shr_vegetationNromalSmooth;
    }

    string $sourceNodes[] = `ls -sl -transforms`;

    if(`size($sourceNodes)` == 0)
    {
        confirmDialog -title "確認" -message "処理対象のノードを選択してから実行してください。" -button "確認";

        return;
    }

    // ソースノード
    global string $gSourceNodes_shr_vegetationNormalSmooth[];
    clear $gSourceNodes_shr_vegetationNormalSmooth;
    $gSourceNodes_shr_vegetationNormalSmooth = $sourceNodes;

    // ソースノードのvisibility
    global int $gSourceNodesVisibility_shr_vegetationNormalSmooth[];
    clear $gSourceNodesVisibility_shr_vegetationNormalSmooth;

    string $elm;

    for($elm in $sourceNodes)
    {
        int $arraySize = `size($gSourceNodesVisibility_shr_vegetationNormalSmooth)`;

        $gSourceNodesVisibility_shr_vegetationNormalSmooth[$arraySize] = `getAttr ($elm + ".visibility")`;
    }

    // プリファレンス設定
    shr_vegetationNormalSmooth_initPreferences;

    // ボクセルメッシュ用 一時マテリアル作成
    string $tempMat = shr_vegetationNormalSmooth_createTempMaterial();

    // HDA ノード作成
    string $hdaNode = shr_vegetationNormalSmooth_createHoudiniAsset($sourceNodes);

    select -r $hdaNode;

    // 生成されたメッシュのアトリビュートを調整
    shr_vegetationNormalSmooth_modifyGeneratedMeshesAttributes($hdaNode);

    // 生成されたメッシュの法線の表示・非表示
    shr_vegetationNormalSmooth_showNormalsCommand($hdaNode, `optionVar -q ov_showNormals_shr_vegetationNormalSmooth`);

    // ソースノードの表示・非表示
    shr_vegetationNormalSmooth_hideSourceMeshesCommand(`optionVar -q ov_hideSourceMeshes_shr_vegetationNormalSmooth`);

    // UI 作成
    shr_vegetationNormalSmooth_createUI($hdaNode, $tempMat);
}

/////////////////////////////////////////////////
// プリファレンス設定
/////////////////////////////////////////////////
global proc shr_vegetationNormalSmooth_initPreferences()
{
    // 表示メッシュタイプ
    if (`optionVar -ex "ov_displayMesh_shr_vegetationNormalSmooth"` == 0)
    {
        optionVar -iv "ov_displayMesh_shr_vegetationNormalSmooth" 0;
    }

    // ボクセルメッシュのカラー
    if (`optionVar -ex "ov_voxelMeshColor_shr_vegetationNormalSmooth"` == 0)
    {
        optionVar -fv "ov_voxelMeshColor_shr_vegetationNormalSmooth" 0.5;
        optionVar -fva "ov_voxelMeshColor_shr_vegetationNormalSmooth" 0.5;
        optionVar -fva "ov_voxelMeshColor_shr_vegetationNormalSmooth" 0.5;
    }

    // ボクセルメッシュの透明度
    if (`optionVar -ex "ov_voxelMeshTransparency_shr_vegetationNormalSmooth"` == 0)
    {
        optionVar -fv "ov_voxelMeshTransparency_shr_vegetationNormalSmooth" 0.8;
        optionVar -fva "ov_voxelMeshTransparency_shr_vegetationNormalSmooth" 0.8;
        optionVar -fva "ov_voxelMeshTransparency_shr_vegetationNormalSmooth" 0.8;
    }

    // 法線を表示
    if (`optionVar -ex "ov_showNormals_shr_vegetationNormalSmooth"` == 0)
    {
        optionVar -iv "ov_showNormals_shr_vegetationNormalSmooth" 1;
    }

    // 元メッシュを非表示
    if (`optionVar -ex "ov_hideSourceMeshes_shr_vegetationNormalSmooth"` == 0)
    {
        optionVar -iv "ov_hideSourceMeshes_shr_vegetationNormalSmooth" 1;
    }
}

/////////////////////////////////////////////////
// UI 作成
/////////////////////////////////////////////////
global proc shr_vegetationNormalSmooth_createUI(string $hdaNode, string $tempMat)
{
    // ウィンドウを閉じたときのコマンド
    string $closeCommand = "shr_vegetationNormalSmooth_closeCommand(\"" + $hdaNode + "\")";

    window
        -title "Vegetation Normal Smooth"
        -resizeToFitChildren on
        -sizeable on
        -toolbox on
        -maximizeButton off
        -mb on
        -closeCommand $closeCommand
        // -w 100 -h 100
        uWnd_shr_vegetationNromalSmooth;

        menu -label "Help" ;

            menuItem
                -label "Vegetation Normal Smooth のヘルプ"
                -c "showHelp -absolute \"https://wisdom.cygames.jp/pages/viewpage.action?pageId=534031063\""
                ;

        // パラメータの小数点以下の桁数
        int $precision = 3;

        columnLayout -adj on;
        frameLayout -lv off -mw 8 -mh 8;
            frameLayout -l "Voxel" -mh 4;
                attrFieldSliderGrp
                    -l "Voxel Size "
                    -ann "ボクセルの粒子サイズ"
                    -min 1.0
                    -max 100.0
                    -pre $precision
                    -at ($hdaNode + ".houdiniAssetParm_voxelsize");

                attrFieldSliderGrp
                    -l "Offset "
                    -ann "ボクセル生成時の形状オフセット値"
                    -min 0.0
                    -max 10.0
                    -pre $precision
                    -at ($hdaNode + ".houdiniAssetParm_voxeloffset");

                attrFieldSliderGrp
                    -l "Iterations "
                    -ann "ボクセルにスムースを繰り返し適用する回数"
                    -min 0
                    -max 10
                    -at ($hdaNode + ".houdiniAssetParm_iterations");

                attrFieldSliderGrp
                    -l "Volume Offset "
                    -ann "ボクセルをポリゴン化する際のオフセット値"
                    -min 0.0
                    -max 500.0
                    -pre 3
                    -at ($hdaNode + ".houdiniAssetParm_offset");

                attrFieldSliderGrp
                    -l "Translate Y "
                    -ann "ボクセルの下部を引き延ばす値"
                    -min -2000.0
                    -max 0.0
                    -pre 3
                    -at ($hdaNode + ".houdiniAssetParm_translatey");

                setParent ..;

            frameLayout -l "Smooth" -mh 4;
                attrFieldSliderGrp
                    -l "Strength "
                    -ann "ボクセルをポリゴン化した後にスムーズを適用する強さ"
                    -min 0.0
                    -max 50.0
                    -pre $precision
                    -at ($hdaNode + ".houdiniAssetParm_strength");

                attrFieldSliderGrp
                    -l "Filter Quality "
                    -ann "ボクセルをポリゴン化した後に適用するスムーズのクオリティ"
                    -min 1
                    -max 5
                    -at ($hdaNode + ".houdiniAssetParm_filterquality");

                setParent ..;

            frameLayout -l "Display Options" -mh 4;

                attrControlGrp
                    -l "Mesh Display"
                    -ann "表示するメッシュ"
                    -cc "shr_vegetationNormalSmooth_displayMeshCommand()"
                    -a ($hdaNode + ".houdiniAssetParm_display_mesh")
                    uAtcg_displayMesh_shr_vegetationNromalSmooth;

                attrControlGrp
                    -l "Color "
                    -ann "ボクセルメッシュのカラー"
                    -hideMapButton true
                    -cc "shr_vegetationNormalSmooth_voxelMeshColorCommand()"
                    -a ($tempMat + ".color")
                    uAtcg_voxelColor_shr_vegetationNromalSmooth;

                attrControlGrp
                    -l "Transparency "
                    -ann "ボクセルメッシュの透明度"
                    -hideMapButton true
                    -cc "shr_vegetationNormalSmooth_voxelMeshTransparencyCommand()"
                    -a ($tempMat + ".transparency")
                    uAtcg_voxelTransparency_shr_vegetationNromalSmooth;

                separator -st "in";

                columnLayout -adj on -co "left" 142;

                    string $onCommand;
                    string $offCommand;

                    $onCommand  = "optionVar -iv ov_showNormals_shr_vegetationNormalSmooth 1;";
                    $onCommand += "shr_vegetationNormalSmooth_showNormalsCommand(\"" + $hdaNode + "\", 1)";
                    $offCommand  = "optionVar -iv ov_showNormals_shr_vegetationNormalSmooth 0;";
                    $offCommand += "shr_vegetationNormalSmooth_showNormalsCommand(\"" + $hdaNode + "\", 0)";

                    checkBox
                        -l "Show Normals"
                        -ann "生成されたメッシュの法線を表示します"
                        -v `optionVar -q ov_showNormals_shr_vegetationNormalSmooth`
                        -onc $onCommand
                        -ofc $offCommand
                        uCb_showNormals_shr_vegetationNromalSmooth;

                    separator -h 8 -st "none";

                    $onCommand  = "optionVar -iv ov_hideSourceMeshes_shr_vegetationNormalSmooth 1;";
                    $onCommand += "shr_vegetationNormalSmooth_hideSourceMeshesCommand(1)";
                    $offCommand  = "optionVar -iv ov_hideSourceMeshes_shr_vegetationNormalSmooth 0;";
                    $offCommand += "shr_vegetationNormalSmooth_hideSourceMeshesCommand(0)";

                    checkBox
                        -l "Hide Source Meshes"
                        -ann "元のメッシュを非表示にします"
                        -v `optionVar -q ov_hideSourceMeshes_shr_vegetationNormalSmooth`
                        -onc $onCommand
                        -ofc $offCommand
                        uCb_hideSourceMeshes_shr_vegetationNromalSmooth;

                setParent ..;
                setParent ..;

            separator -st "in";

        string $form = `formLayout`;

            // ウィンドウを閉じたときのコマンド
            string $applyCommand = "shr_vegetationNormalSmooth_applyCommand(\"" + $hdaNode + "\")";

            string $btn1 = `button -l "適用" -bgc 0.5 0.6 0.5 -c $applyCommand`;
            string $btn2 = `button -l "キャンセル" -c "deleteUI uWnd_shr_vegetationNromalSmooth"`;

        formLayout -e
            -attachNone     $btn1     "top"
            -attachForm     $btn1     "left"   4
            -attachNone     $btn1     "bottom"
            -attachPosition $btn1     "right" 2 70

            -attachNone     $btn2     "top"
            -attachPosition $btn2     "left" 2  70
            -attachNone     $btn2     "bottom"
            -attachForm     $btn2     "right"  4
            $form;

    showWindow;
}

/////////////////////////////////////////////////
// Display Mesh プルダウンのコールバック
/////////////////////////////////////////////////
global proc shr_vegetationNormalSmooth_displayMeshCommand()
{
    string $attributeName = `attrControlGrp -q -a uAtcg_displayMesh_shr_vegetationNromalSmooth`;

    int $displayMesh = `getAttr $attributeName`;

    optionVar -iv "ov_displayMesh_shr_vegetationNormalSmooth" $displayMesh;

    // HDA ノード名を取得
    string $tokens[];
    tokenize $attributeName "." $tokens;
    string $hdaNode = $tokens[0];

    // Sync Asset
    houdiniEngine_syncAssetOutput $hdaNode;

    shr_vegetationNormalSmooth_modifyGeneratedMeshesAttributes($hdaNode);

    int $showNormals = `optionVar -q ov_showNormals_shr_vegetationNormalSmooth`;

    // 法線表示
    shr_vegetationNormalSmooth_showNormalsCommand($hdaNode, $showNormals);
}

/////////////////////////////////////////////////
// Color スライダのコールバック
/////////////////////////////////////////////////
global proc shr_vegetationNormalSmooth_voxelMeshColorCommand()
{
    string $attributeName = `attrControlGrp -q -a uAtcg_voxelColor_shr_vegetationNromalSmooth`;

    float $color[] = `getAttr $attributeName`;

    optionVar -ca "ov_voxelMeshColor_shr_vegetationNormalSmooth";
    optionVar -fva "ov_voxelMeshColor_shr_vegetationNormalSmooth" $color[0];
    optionVar -fva "ov_voxelMeshColor_shr_vegetationNormalSmooth" $color[1];
    optionVar -fva "ov_voxelMeshColor_shr_vegetationNormalSmooth" $color[2];
}

/////////////////////////////////////////////////
// Transparency スライダのコールバック
/////////////////////////////////////////////////
global proc shr_vegetationNormalSmooth_voxelMeshTransparencyCommand()
{
    string $attributeName = `attrControlGrp -q -a uAtcg_voxelTransparency_shr_vegetationNromalSmooth`;

    float $transparency[] = `getAttr $attributeName`;

    optionVar -ca "ov_voxelMeshTransparency_shr_vegetationNormalSmooth";
    optionVar -fva "ov_voxelMeshTransparency_shr_vegetationNormalSmooth" $transparency[0];
    optionVar -fva "ov_voxelMeshTransparency_shr_vegetationNormalSmooth" $transparency[1];
    optionVar -fva "ov_voxelMeshTransparency_shr_vegetationNormalSmooth" $transparency[2];
}

/////////////////////////////////////////////////
// Show Normals チェックボックスのコールバック
/////////////////////////////////////////////////
global proc shr_vegetationNormalSmooth_showNormalsCommand(string $hdaNode, int $showNormals)
{
    string $generatedMeshes[] = shr_vegetationNormalSmooth_getGeneratedMeshes($hdaNode);

    string $elm;

    for($elm in $generatedMeshes)
    {
        setAttr ($elm + ".normalType") 2;
        setAttr ($elm + ".displayNormal") $showNormals;
    }
}

/////////////////////////////////////////////////
// Hide Source Meshes チェックボックスのコールバック
/////////////////////////////////////////////////
global proc shr_vegetationNormalSmooth_hideSourceMeshesCommand(int $hideSourceMeshes)
{
    global string $gSourceNodes_shr_vegetationNormalSmooth[];
    global int $gSourceNodesVisibility_shr_vegetationNormalSmooth[];

    int $index;

    string $elm;

    for($elm in $gSourceNodes_shr_vegetationNormalSmooth)
    {
        if(`objExists $elm` == false)
        {
            $index += 1;
            continue;
        }

        if($hideSourceMeshes)
        {
            setAttr ($elm + ".visibility") false;
        }
        else
        {
            if($gSourceNodesVisibility_shr_vegetationNormalSmooth[$index])
            {
                setAttr ($elm + ".visibility") 1;
            }
        }

        $index += 1;
    }
}

/////////////////////////////////////////////////
// 適用ボタンのコールバック
/////////////////////////////////////////////////
global proc shr_vegetationNormalSmooth_applyCommand(string $hdaNode)
{
    // リザルトメッシュのみ表示
    setAttr ($hdaNode + ".houdiniAssetParm_display_mesh") 0;

    // HDA から出力されたメッシュをベイクし再構築する
    shr_rebuildHdaOutputMeshes($hdaNode);

    // ウィンドウを削除
    deleteUI uWnd_shr_vegetationNromalSmooth;
}

/////////////////////////////////////////////////
// ウィンドウを閉じたときのコールバック
/////////////////////////////////////////////////
global proc shr_vegetationNormalSmooth_closeCommand(string $hdaNode)
{
    // ソースノード
    global string $gSourceNodes_shr_vegetationNormalSmooth[];

    // ソースノードのvisibility
    global int $gSourceNodesVisibility_shr_vegetationNormalSmooth[];

    if(`objExists $hdaNode`)
    {
        delete $hdaNode;
    }

    string $elm;

    int $index;

    select -clear;

    // ソースノードが残っていれば表示状態と選択を復元
    for($elm in $gSourceNodes_shr_vegetationNormalSmooth)
    {
        if(`objExists $elm`)
        {
            setAttr ($elm + ".visibility") $gSourceNodesVisibility_shr_vegetationNormalSmooth[$index];

            select -add $elm;
        }

        $index += 1;
    }

    // 一時マテリアルを削除
    shr_vegetationNormalSmooth_deleteTempMaterial;

    // グローバル変数を削除
    clear $gSourceNodes_shr_vegetationNormalSmooth;
    clear $gSourceNodesVisibility_shr_vegetationNormalSmooth;
}

/////////////////////////////////////////////////
// Houdini Asset Node を作成
/////////////////////////////////////////////////
global proc string shr_vegetationNormalSmooth_createHoudiniAsset(string $meshInputNodes[])
{
    // hda ノード作成
    string $hdaNode = houdiniEngine_loadAsset("C:/cygames/shrdev/shr/tools/in/ext/maya/share/hda/mtk_vegetation_normal_smooth.hda", "Sop/mtk_vegetation_normal_smooth");

    setAttr ($hdaNode + ".syncWhenInputConnects") false;

    // 出力メッシュをグループで分割
    setAttr ($hdaNode + ".splitGeosByGroup") true;

    // グループのセットを作成しない
    setAttr ($hdaNode + ".outputGeometryGroups") false;

    // シェーディンググループを指定
    setAttr ($hdaNode + ".houdiniAssetParm_shading_group") -type "string" "temp_voxel_matSG";

    // 表示メッシュを指定
    setAttr ($hdaNode + ".houdiniAssetParm_display_mesh") `optionVar -q ov_displayMesh_shr_vegetationNormalSmooth`;

    // Mesh インプットに入力
    houdiniEngine_setAssetInput(($hdaNode + ".input[0].inputNodeId"), $meshInputNodes);

    // Sync Asset
    houdiniEngine_syncAssetOutput $hdaNode;

    // Auto Sync Output
    // setAttr ($hdaNode + ".autoSyncOutputs") true;

    return $hdaNode;
}

/////////////////////////////////////////////////
// Houdini Asset Node で作成されたメッシュのアトリビュートを変更
/////////////////////////////////////////////////
global proc shr_vegetationNormalSmooth_modifyGeneratedMeshesAttributes(string $hdaNode)
{
    string $generatedMeshes[] = shr_vegetationNormalSmooth_getGeneratedMeshes($hdaNode);

    string $elm;

    for($elm in $generatedMeshes)
    {
        setAttr ($elm + ".displayColors") false;
    }
}

/////////////////////////////////////////////////
// Houdini Asset Node で生成されたメッシュを取得
/////////////////////////////////////////////////
global proc string[] shr_vegetationNormalSmooth_getGeneratedMeshes(string $hdaNode)
{
    string $generatedMeshes[] = `listRelatives -ad -pa -type "mesh" $hdaNode`;

    return $generatedMeshes;
}

/////////////////////////////////////////////////
// ボクセルメッシュ用 一時マテリアル作成
/////////////////////////////////////////////////
global proc string shr_vegetationNormalSmooth_createTempMaterial()
{
    string $tempVoxelMat = "temp_voxel_mat";
    string $tempVoxelMatSG = $tempVoxelMat + "SG";

    if(`objExists $tempVoxelMat` == false)
    {
        // マテリアル作成
        shadingNode -asShader "lambert" -name $tempVoxelMat;

        if(`objExists $tempVoxelMatSG` == false)
        {
            // シェーディンググループ作成
            sets -renderable true -noSurfaceShader true -empty -name $tempVoxelMatSG;
        }

        connectAttr ($tempVoxelMat + ".outColor") ($tempVoxelMatSG + ".surfaceShader");
    }

    // カラーを設定
    float $color[] = `optionVar -q "ov_voxelMeshColor_shr_vegetationNormalSmooth"`;
    setAttr "temp_voxel_mat.color" -type double3 $color[0] $color[1] $color[2];

    // 透明度を設定
    float $transparency[] = `optionVar -q "ov_voxelMeshTransparency_shr_vegetationNormalSmooth"`;
    setAttr "temp_voxel_mat.transparency" -type double3 $transparency[0] $transparency[1] $transparency[2];

    return $tempVoxelMat;
}

/////////////////////////////////////////////////
// ボクセルメッシュ用 一時マテリアル削除
/////////////////////////////////////////////////
global proc shr_vegetationNormalSmooth_deleteTempMaterial()
{
    string $tempVoxelMat = "temp_voxel_mat";
    string $tempVoxelMatSG = $tempVoxelMat + "SG";

    if(`objExists $tempVoxelMat`)
    {
        delete $tempVoxelMat;

        if(`objExists $tempVoxelMatSG` == false)
        {
            delete $tempVoxelMatSG;
        }
    }
}

// NOTE:
// shr_vegetationNormalSmooth;