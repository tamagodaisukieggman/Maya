//===============================================
//
//  階層をチェックして修正
//
//===============================================

//
// -1: 修正キャンセル（問題あり）
// 0: 修正の必要なし
// 1: 修正完了
//
global proc int shr_fixHierarchy(string $root_nodes[])
{
    source "shr_nodeHierarchyAssistant";

    // ルートノードが指定されなかった場合、全てのルートノードをチェック対象に
    if(`size($root_nodes)` == 0)
    {
        $root_nodes = `ls "|*"`;
    }

    // リネームする必要があるノード
    string $nodes_needs_rename[];

    // lodGroup を作成する必要があるノード
    string $nodes_needs_create_lod_group[];

    string $root_node;

    int $check_result;

    // 修正の必要があるノードをチェック
    for($root_node in $root_nodes)
    {
        // ルートノード名チェック
        $check_result = shr_fixHierarchy_checkRootNodeName($root_node);

        // アセットノード名でない場合
        if($check_result == 0)
        {
            continue;
        }

        // 旧仕様のアセットノード名の場合
        if($check_result == 2)
        {
            $nodes_needs_rename[`size($nodes_needs_rename)`] = $root_node;
        }

        // lodGroup ノードが存在するか
        $check_result = shr_fixHierarchy_lodGroupNodesExists($root_node);

        // 存在しない場合
        if($check_result == 0)
        {
            $nodes_needs_create_lod_group[`size($nodes_needs_create_lod_group)`] = $root_node;
        }
    }

    if(`size($nodes_needs_rename)` + `size($nodes_needs_create_lod_group)` == 0)
    {
        return 0;
    }

    string $message = "以下のアセットの階層構造が仕様に沿っていません。\n\n";

    // 修正対象ノードリスト
    string $target_nodes[] = stringArrayCatenate($nodes_needs_rename, $nodes_needs_create_lod_group);
    $target_nodes = stringArrayRemoveDuplicates($target_nodes);

    string $target_node;

    for($target_node in $target_nodes)
    {
        $message += $target_node + "\n";
    }

    $message += "\n階層構造を自動修正しますか？";

    // 確認ダイアログ
    string $result =
    `confirmDialog
        -title "確認"
        -icon "warning"
        -message $message
        -button "はい"
        -button "キャンセル"
        -defaultButton "はい"
        -cancelButton "キャンセル"
        -dismissString "キャンセル"`
        ;

    // キャンセル
    if ($result == "キャンセル")
    {
        return -1;
    }

    // lodGroup ノードを作成
    for($target_node in $nodes_needs_create_lod_group)
    {
        shr_fixHierarchy_createLodGroupNode($target_node);
    }

    // ルートノード名を修正
    for($target_node in $nodes_needs_rename)
    {
        shr_fixHierarchy_fixRootNodeName($target_node);
    }

    return 1;
}

///////////////////////////////////////
// ルートノード名チェック
//
// 0: アセットノード名ではない
// 1: 正しいアセットノード名
// 2: 旧仕様のアセットノード名
///////////////////////////////////////
global proc int shr_fixHierarchy_checkRootNodeName(string $node_name)
{
    // 旧 背景アセット命名 正規表現
    string $regExEnvOld = "^s_r[0-9][0-9]_(s99)*[a-z]+[0-9][0-9]_[0-9][0-9]_$";

    // 旧 背景植生アセット命名 正規表現
    string $regExEnvVgtOld = "^s_vgt_(s99)*[a-z]+[0-9][0-9]_[0-9][0-9]_$";

    // 背景アセット命名 正規表現
    string $regExEnv = "^r[0-9][0-9]_(s99)*[a-z]+[0-9][0-9]_[0-9][0-9]$";

    // 背景植生アセット命名 正規表現
    string $regExEnvVgt = "^vgt_([rs]99)*[a-z]+[0-9][0-9]_[0-9][0-9]$";

    // 背景リピートマテリアル命名 正規表現
    string $regExEnvRep = "^rep_(s99)*[a-z]+[0-9][0-9]_[0-9][0-9]$";

    // 背景デカールマテリアル命名 正規表現
    string $regExEnvDcl = "^dcl_(s99)*[a-z]+[0-9][0-9]_[0-9][0-9]$";

    // キャラアセット命名 正規表現
    string $regExChr = "^[a-z][a-z][a-z][0-9][0-9][0-9][0-9]$";

    // 正しいアセットノード名の場合
    if(`match $regExEnv $node_name` != "" || `match $regExEnvVgt $node_name` != "" || `match $regExEnvRep $node_name` != "" || `match $regExEnvDcl $node_name` != "" || `match $regExChr $node_name` != "")
    {
        return 1;
    }
    // 旧仕様のアセットノード名の場合
    else if(`match $regExEnvOld $node_name` != "" || `match $regExEnvVgtOld $node_name` != "")
    {
        return 2;
    }

    // アセットノード名ではない場合
    return 0;
}

///////////////////////////////////////
// ルートノード名を修正
///////////////////////////////////////
global proc string shr_fixHierarchy_fixRootNodeName(string $old_root_node_name)
{
    // アセット名抽出用 正規表現
    string $regEx = "..._(s99)*[a-z]+[0-9][0-9]_[0-9][0-9]";

    // アセットノード名を抽出
    string $new_root_node_name = `match $regEx $old_root_node_name`;

    rename $old_root_node_name $new_root_node_name;

    print `format -s $old_root_node_name -s $new_root_node_name "// ルートノード名を修正: ^1s -> ^2s\n"`;

    return $new_root_node_name;
}

///////////////////////////////////////
// lodGroup ノードが存在するか
///////////////////////////////////////
global proc int shr_fixHierarchy_lodGroupNodesExists(string $static_mesh_node)
{
    // スタティックメッシュアセットの子ノードをフルパス名で取得
    string $lodGroupNodes[] = `listRelatives -c -f -type "lodGroup" $static_mesh_node`;

    if(`size($lodGroupNodes)` != 0)
    {
        return 1;
    }

    return 0;
}

///////////////////////////////////////
// lodGroup ノードを作成・階層組み換え
///////////////////////////////////////
global proc shr_fixHierarchy_createLodGroupNode(string $static_mesh_node)
{
    // 現在の選択リストを取得
    string $sel[] = `ls -sl`;

    // 現在の選択をクリア
    select -clear;

    // lodGroup を作成
    LevelOfDetailGroup;

    // 作成したlodGroup ノード
    string $createdNodes[] = `ls -sl`;
    string $lodGroupNode = $createdNodes[0];

    // lodGroup ノードのThreshold Type を変更
    setAttr ($lodGroupNode + ".useScreenHeightPercentage") 1;

    // デフォルトで付いているlod ノードを削除
    string $defaultLodNodes[] = `listRelatives -c -f $lodGroupNode`;
    delete $defaultLodNodes;

    // lodGroup ノードをスタティックメッシュノードの子に
    string $parentedLodGroupNode[] = `parent $lodGroupNode $static_mesh_node`;

    // スタティックメッシュアセットの子ノードを取得
    string $childNodes[] = `listRelatives -c -f -type "transform" $static_mesh_node`;

    string $childNode;

    string $targetNodes[];

    string $original_mesh_node;

    // mesh ノードが存在する場合、その子供の移動対象ノードを取得
    for($childNode in $childNodes)
    {
        // meshノードの場合
        if(endsWith($childNode, "|mesh"))
        {
            $original_mesh_node = $childNode;

            $targetNodes = shr_fixHierarchy_getTargetLodNodes($childNode);

            break;
        }
    }

    int $remove_original_mesh_node = 0;

    // mesh ノードの子供に移動対象ノードがなかった場合
    if(`size($targetNodes)` == 0)
    {
        $targetNodes = shr_fixHierarchy_getTargetLodNodes($static_mesh_node);
    }
    else
    {
        $remove_original_mesh_node = 1;
    }

    string $targetNode;

    for($targetNode in $targetNodes)
    {
        // 移動対象のノードをlodGroup ノードの子に
        parent $targetNode $parentedLodGroupNode[0];
    }

    // lodGroup 表示設定を全てshow に
    shr_nodeHierarchyAssistant_setLodDisplayLevelToShow($parentedLodGroupNode[0]);

    // 元のmesh ノードがあれば削除
    if($remove_original_mesh_node)
    {
        delete $original_mesh_node;
    }

    // lodGroup ノード名をmesh にリネーム
    rename $parentedLodGroupNode[0] "mesh";

    print `format -s $static_mesh_node "// lodGroup ノードを作成: ^1s\n"`;

    // 選択を復元
    select -r $sel;
}

///////////////////////////////////////
// 移動対象のlod* ノードを取得
///////////////////////////////////////
global proc string[] shr_fixHierarchy_getTargetLodNodes(string $node)
{
  // 移動対象のノード名
    string $targetNodeNames[] = {
        "|model",
        "|mesh",
        "|lod0",
        "|lod1",
        "|lod2",
        "|lod3",
        "|lod4",
        "|lod5",
        "|lod6",
        "|lod7",
        "|lod8",
        "|lod9"
    };

    string $targetNodes[];

    // 子ノードを取得
    string $childNodes[] = `listRelatives -c -f -type "transform" $node`;

    string $childNode;

    for($childNode in $childNodes)
    {
        string $targetNodeName;

        for($targetNodeName in $targetNodeNames)
        {
            // 移動対象のノードの場合
            if(endsWith($childNode, $targetNodeName))
            {
                // mesh ノードの場合はlod0 にリネーム
                if($targetNodeName == "|mesh" || $targetNodeName == "|model")
                {
                    $childNode = `rename $childNode "lod0"`;
                }

                $targetNodes[`size($targetNodes)`] = $childNode;

                break;
            }
        }
    }

    return $targetNodes;
}

// shr_fixHierarchy({});
