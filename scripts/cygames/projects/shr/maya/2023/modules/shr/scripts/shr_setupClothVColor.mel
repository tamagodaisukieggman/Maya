//===============================================
//
// 風揺れ布マテリアル用の頂点カラー＆UV 設定ツール
//
//===============================================

global proc shr_setupClothVColor()
{
    source "shr_rebuildHdaOutputMeshes";

    if (`window -exists uWnd_shr_setupClothVColor`)
    {
        return;
        // deleteUI uWnd_shr_setupClothVColor;
    }

    // NOTE: ツールログ送信
    shr_toolLog("Setup Cloth Vertex Color", "", "launched.");

    // Houdini 環境が有効か
    int $houdiniEngineEnabled = python("import shr.utils.hda_loader.houdini_util as houdini_util; houdini_util.main()");

    // プラグインのロード待ちして実行
    evalDeferred("shr_setupClothVColor_main");
}

/////////////////////////////////////////////////
// メイン
/////////////////////////////////////////////////
global proc shr_setupClothVColor_main()
{
    string $sourceNodes[] = `ls -sl -transforms`;

    if(`size($sourceNodes)` == 0)
    {
        confirmDialog -title "確認" -message "処理対象のノードを選択してから実行してください。" -button "確認";

        return;
    }

    // ソースノード
    global string $gSourceNodes_shr_setupClothVColor[];
    clear $gSourceNodes_shr_setupClothVColor;
    $gSourceNodes_shr_setupClothVColor = $sourceNodes;

    // ソースノードのvisibility
    global int $gSourceNodesVisibility_shr_setupClothVColor[];
    clear $gSourceNodesVisibility_shr_setupClothVColor;

    string $elm;

    for($elm in $sourceNodes)
    {
        int $arraySize = `size($gSourceNodesVisibility_shr_setupClothVColor)`;

        $gSourceNodesVisibility_shr_setupClothVColor[$arraySize] = `getAttr ($elm + ".visibility")`;
    }

    // プリファレンス設定
    shr_setupClothVColor_initPreferences;

    // ボクセルメッシュ用 一時マテリアル作成
    string $tempMat = shr_setupClothVColor_createTempMaterial();

    // HDA ノード作成して選択
    global string $gHdaNode_shr_setupClothVColor;
    $gHdaNode_shr_setupClothVColor = shr_setupClothVColor_createHoudiniAsset($sourceNodes);
    select -r $gHdaNode_shr_setupClothVColor;

    // 前回実行時のパラメータを適用
    shr_setupClothVColor_restoreParamsFromCustomAttributes();

    shr_setupClothVColor_syncAsset;

    // ソースノードの表示・非表示
    shr_setupClothVColor_hideSourceMeshesCommand(`optionVar -q ov_hideSourceMeshes_shr_setupClothVColor`);

    // UI 作成
    shr_setupClothVColor_createUI($tempMat);

    // 表示メッシュがresult 以外の時はボクセル表示のコントロールを有効化
    shr_setupClothVColor_displayMeshCommand();

}

/////////////////////////////////////////////////
// UI 作成
/////////////////////////////////////////////////
global proc shr_setupClothVColor_createUI(string $tempMat)
{
    // HDA ノード
    global string $gHdaNode_shr_setupClothVColor;

    window
        -title "Setup Cloth Vertex Color"
        -resizeToFitChildren on
        -sizeable on
        -toolbox on
        -maximizeButton off
        -mb on
        -closeCommand "shr_setupClothVColor_closeCommand"
        // -w 100 -h 100
        uWnd_shr_setupClothVColor;

        menu -label "Help" ;

            menuItem
                -label "Setup Cloth Vertex Color のヘルプ"
                -c "showHelp -absolute \"https://wisdom.cygames.jp/pages/viewpage.action?pageId=651841731\""
                ;

        // パラメータの小数点以下の桁数
        int $precision = 3;

        string $syncAssetCmd = "shr_setupClothVColor_syncAsset";

        columnLayout -adj on;
        frameLayout -lv off -mw 8 -mh 8;

            frameLayout -l "Cloth" -mh 4;
                attrFieldSliderGrp
                    -l "Sway Mask Length "
                    -ann "揺れマスクの長さ"
                    -min 0.0
                    -max 100.0
                    -pre $precision
                    -cc $syncAssetCmd
                    -at ($gHdaNode_shr_setupClothVColor + ".houdiniAssetParm_sway_mask_length");

                attrControlGrp
                    -l "Use Cage Mesh"
                    -ann "揺れマスクの長さ基準にケージメッシュを使用"
                    -a ($gHdaNode_shr_setupClothVColor + ".houdiniAssetParm_use_cage_mesh")
                    -cc $syncAssetCmd
                    uAtcg_useCageMesh_setupClothVColor;

                // columnLayout -adj on uCl_voxelSettings_shr_setupClothVColor;
                //     attrFieldSliderGrp
                //         -l "Voxel Size "
                //         -ann "ボクセルの粒子サイズ"
                //         -min 1.0
                //         -max 100.0
                //         -pre $precision
                //         -cc $syncAssetCmd
                //         -at ($gHdaNode_shr_setupClothVColor + ".houdiniAssetParm_voxelsize");

                //     attrFieldSliderGrp
                //         -l "Voxel Translate Y "
                //         -ann "ボクセルの下部を引き延ばす値"
                //         -min -2000.0
                //         -max 0.0
                //         -pre 3
                //         -cc $syncAssetCmd
                //         -at ($gHdaNode_shr_setupClothVColor + ".houdiniAssetParm_translatey");

                //     attrFieldSliderGrp
                //         -l "Voxel Offset "
                //         -ann "ボクセル生成時の形状オフセット値"
                //         -min 0.0
                //         -max 10.0
                //         -pre $precision
                //         -cc $syncAssetCmd
                //         -at ($gHdaNode_shr_setupClothVColor + ".houdiniAssetParm_voxeloffset");

                //     setParent ..;
                setParent ..;

            frameLayout -l "Pinning" -mh 4;

                rowLayout -nc 2 -adj 2 -cw 1 142 -cat 1 "right" 0;

                    text -l "Pinning Meshes ";

                    columnLayout -adj on;

                        textScrollList -h 100 uTsl_pinMeshList_shr_setupClothVColor;

                        rowLayout -nc 3;
                            button
                                -l "Set to Pinning Mesh"
                                -ann "選択ノードをピン留めメッシュに設定"
                                -c ("shr_setupClothVColor_setToPinningMeshButtonCommand;" + $syncAssetCmd);

                            text -l "";

                            button
                                -l "Reset Pinning Mesh"
                                -ann "ピン留めメッシュをクリア"
                                -c ("shr_setupClothVColor_resetPinningMeshButtonCommand;" + $syncAssetCmd);

                            setParent..;

                        setParent ..;
                    setParent ..;

                columnLayout -en off -adj on uCl_collitionSettings_shr_setupClothVColor;

                    attrFieldSliderGrp
                        -l "Influence Range "
                        -ann "ピン留めの影響範囲"
                        -min 0.0
                        -max 100.0
                        -pre $precision
                        -cc $syncAssetCmd
                        -at ($gHdaNode_shr_setupClothVColor + ".houdiniAssetParm_pin_radius");

                    attrFieldSliderGrp
                        -l "Falloff Distance "
                        -ann "ピン留めのフォールオフ距離"
                        -min 0.0
                        -max 100.0
                        -pre $precision
                        -cc $syncAssetCmd
                        -at ($gHdaNode_shr_setupClothVColor + ".houdiniAssetParm_pin_falloff_dist");

                    setParent ..;
                setParent ..;

            frameLayout -l "Debug View" -mh 4;

                columnLayout -adj on -co "left" 142;

                    string $onCommand;
                    string $offCommand;

                    $onCommand  = "optionVar -iv ov_hideSourceMeshes_shr_setupClothVColor 1;";
                    $onCommand += "shr_setupClothVColor_hideSourceMeshesCommand(1)";
                    $offCommand  = "optionVar -iv ov_hideSourceMeshes_shr_setupClothVColor 0;";
                    $offCommand += "shr_setupClothVColor_hideSourceMeshesCommand(0)";

                    checkBox
                        -l "Hide Source Meshes"
                        -ann "元のメッシュを非表示にします"
                        -v `optionVar -q ov_hideSourceMeshes_shr_setupClothVColor`
                        -onc $onCommand
                        -ofc $offCommand
                        uCb_hideSourceMeshes_shr_setupClothVColor;

                    setParent ..;

                attrControlGrp
                    -l "Vertex Color View "
                    -ann "頂点カラー表示"
                    -cc ("shr_setupClothVColor_vertexColorDebugViewCommand;" + $syncAssetCmd)
                    -a ($gHdaNode_shr_setupClothVColor + ".houdiniAssetParm_vertex_color_debug_view")
                    uAtcg_vertexColorDebugView_shr_setupClothVColor;

                attrControlGrp
                    -l "Mesh Display "
                    -ann "表示するメッシュ"
                    -cc ("shr_setupClothVColor_displayMeshCommand;" + $syncAssetCmd)
                    -a ($gHdaNode_shr_setupClothVColor + ".houdiniAssetParm_display_mesh")
                    uAtcg_displayMesh_shr_setupClothVColor;

                columnLayout -adj on uCl_voxelDisplaySettings_shr_setupClothVColor;

                    attrControlGrp
                        -l "Voxel Mesh Color "
                        -ann "ボクセルメッシュのカラー"
                        -hideMapButton true
                        -cc "shr_setupClothVColor_voxelMeshColorCommand()"
                        -a ($tempMat + ".color")
                        uAtcg_voxelColor_shr_setupClothVColor;

                    attrControlGrp
                        -l "Voxel mesh Transparency "
                        -ann "ボクセルメッシュの透明度"
                        -hideMapButton true
                        -cc "shr_setupClothVColor_voxelMeshTransparencyCommand()"
                        -a ($tempMat + ".transparency")
                        uAtcg_voxelTransparency_shr_setupClothVColor;

                    $onCommand  = "optionVar -iv ov_showNormals_shr_setupClothVColor 1;";
                    $onCommand += "shr_setupClothVColor_showNormalsCommand(1)";
                    $offCommand  = "optionVar -iv ov_showNormals_shr_setupClothVColor 0;";
                    $offCommand += "shr_setupClothVColor_showNormalsCommand(0)";

                    columnLayout -adj on -co "left" 142;
                        checkBox
                            -l "Show Voxel Mesh Normals"
                            -ann "ボクセルメッシュの法線を表示します"
                            -v `optionVar -q ov_showNormals_shr_setupClothVColor`
                            -onc $onCommand
                            -ofc $offCommand
                            uCb_showNormals_shr_setupClothVColor;

                        setParent ..;
                    setParent ..;
                setParent ..;

            separator -st "in";

        string $form = `formLayout`;

            // 適用コマンド
            string $applyCommand = "shr_setupClothVColor_applyCommand";

            string $btn1 = `button -l "適用" -bgc 0.5 0.6 0.5 -c $applyCommand`;
            string $btn2 = `button -l "キャンセル" -c "deleteUI uWnd_shr_setupClothVColor"`;

        formLayout -e
            -attachNone     $btn1     "top"
            -attachForm     $btn1     "left"   4
            -attachNone     $btn1     "bottom"
            -attachPosition $btn1     "right" 2 70

            -attachNone     $btn2     "top"
            -attachPosition $btn2     "left" 2  70
            -attachNone     $btn2     "bottom"
            -attachForm     $btn2     "right"  4
            $form;

    // テキストスクロールリストの更新
    shr_setupClothVColor_updateTextScrollList;

    showWindow;
}

/////////////////////////////////////////////////
// テキストスクロールリストの更新
/////////////////////////////////////////////////
global proc shr_setupClothVColor_updateTextScrollList()
{
    // HDA ノード
    global string $gHdaNode_shr_setupClothVColor;

    string $colMeshes[] = houdiniEngine_getAssetInput(($gHdaNode_shr_setupClothVColor + ".input[1].inputNodeId"));

    textScrollList -e -removeAll uTsl_pinMeshList_shr_setupClothVColor;

    string $colMesh;

    for($colMesh in $colMeshes)
    {
        textScrollList -e -a $colMesh uTsl_pinMeshList_shr_setupClothVColor;
    }

    columnLayout -e -enable `size($colMeshes)` uCl_collitionSettings_shr_setupClothVColor;
}

/////////////////////////////////////////////////
// Set to Pinning Mesh ボタンのコールバック
/////////////////////////////////////////////////
global proc shr_setupClothVColor_setToPinningMeshButtonCommand()
{
    // HDA ノード
    global string $gHdaNode_shr_setupClothVColor;

    string $collisionNodes[] = `ls -sl -transforms`;

    houdiniEngine_setAssetInput(($gHdaNode_shr_setupClothVColor + ".input[1].inputNodeId"), $collisionNodes);

    // テキストスクロールリストの更新
    shr_setupClothVColor_updateTextScrollList;

    columnLayout -e -enable on uCl_collitionSettings_shr_setupClothVColor;
}

/////////////////////////////////////////////////
// Reset Pinning Mesh ボタンのコールバック
/////////////////////////////////////////////////
global proc shr_setupClothVColor_resetPinningMeshButtonCommand()
{
    // HDA ノード
    global string $gHdaNode_shr_setupClothVColor;

    houdiniEngine_setAssetInput(($gHdaNode_shr_setupClothVColor + ".input[1].inputNodeId"), {});

    textScrollList -e -removeAll uTsl_pinMeshList_shr_setupClothVColor;

    columnLayout -e -enable off uCl_collitionSettings_shr_setupClothVColor;
}

/////////////////////////////////////////////////
// Sync Asset
/////////////////////////////////////////////////
global proc shr_setupClothVColor_syncAsset()
{
    // HDA ノード
    global string $gHdaNode_shr_setupClothVColor;

    // Sync Asset
    houdiniEngine_syncAssetOutput $gHdaNode_shr_setupClothVColor;

    // ボクセルメッシュの頂点カラー表示をオフに
    shr_setupClothVColor_disableVoxelMeshVColors;

    // 法線表示
    int $showNormals = `optionVar -q ov_showNormals_shr_setupClothVColor`;
    shr_setupClothVColor_showNormalsCommand($showNormals);
}

/////////////////////////////////////////////////
// Vertex Color Debug View プルダウンのコールバック
/////////////////////////////////////////////////
global proc shr_setupClothVColor_vertexColorDebugViewCommand()
{
    string $attributeName = `attrControlGrp -q -a uAtcg_vertexColorDebugView_shr_setupClothVColor`;

    int $vertexColorDebugView = `getAttr $attributeName`;

    optionVar -iv "ov_vertexColorDebugView_shr_setupClothVColor" $vertexColorDebugView;
}

/////////////////////////////////////////////////
// Display Mesh プルダウンのコールバック
/////////////////////////////////////////////////
global proc shr_setupClothVColor_displayMeshCommand()
{
    string $attributeName = `attrControlGrp -q -a uAtcg_displayMesh_shr_setupClothVColor`;

    int $displayMesh = `getAttr $attributeName`;

    optionVar -iv "ov_displayMesh_shr_setupClothVColor" $displayMesh;

    // 表示メッシュがresult 以外の時はボクセル表示のコントロールを有効化
    columnLayout -e -en $displayMesh uCl_voxelDisplaySettings_shr_setupClothVColor;
}

/////////////////////////////////////////////////
// Color スライダのコールバック
/////////////////////////////////////////////////
global proc shr_setupClothVColor_voxelMeshColorCommand()
{
    string $attributeName = `attrControlGrp -q -a uAtcg_voxelColor_shr_setupClothVColor`;

    float $color[] = `getAttr $attributeName`;

    optionVar -ca "ov_voxelMeshColor_shr_setupClothVColor";
    optionVar -fva "ov_voxelMeshColor_shr_setupClothVColor" $color[0];
    optionVar -fva "ov_voxelMeshColor_shr_setupClothVColor" $color[1];
    optionVar -fva "ov_voxelMeshColor_shr_setupClothVColor" $color[2];
}

/////////////////////////////////////////////////
// Transparency スライダのコールバック
/////////////////////////////////////////////////
global proc shr_setupClothVColor_voxelMeshTransparencyCommand()
{
    string $attributeName = `attrControlGrp -q -a uAtcg_voxelTransparency_shr_setupClothVColor`;

    float $transparency[] = `getAttr $attributeName`;

    optionVar -ca "ov_voxelMeshTransparency_shr_setupClothVColor";
    optionVar -fva "ov_voxelMeshTransparency_shr_setupClothVColor" $transparency[0];
    optionVar -fva "ov_voxelMeshTransparency_shr_setupClothVColor" $transparency[1];
    optionVar -fva "ov_voxelMeshTransparency_shr_setupClothVColor" $transparency[2];
}

/////////////////////////////////////////////////
// プリファレンス設定
/////////////////////////////////////////////////
global proc shr_setupClothVColor_initPreferences()
{
    // 頂点カラーデバッグ表示タイプ
    if (`optionVar -ex "ov_vertexColorDebugView_shr_setupClothVColor"` == 0)
    {
        optionVar -iv "ov_vertexColorDebugView_shr_setupClothVColor" 1;
    }

    // 表示メッシュタイプ
    if (`optionVar -ex "ov_displayMesh_shr_setupClothVColor"` == 0)
    {
        optionVar -iv "ov_displayMesh_shr_setupClothVColor" 0;
    }

    // ボクセルメッシュのカラー
    if (`optionVar -ex "ov_voxelMeshColor_shr_setupClothVColor"` == 0)
    {
        optionVar -fv "ov_voxelMeshColor_shr_setupClothVColor" 0.5;
        optionVar -fva "ov_voxelMeshColor_shr_setupClothVColor" 0.5;
        optionVar -fva "ov_voxelMeshColor_shr_setupClothVColor" 0.5;
    }

    // ボクセルメッシュの透明度
    if (`optionVar -ex "ov_voxelMeshTransparency_shr_setupClothVColor"` == 0)
    {
        optionVar -fv "ov_voxelMeshTransparency_shr_setupClothVColor" 0.8;
        optionVar -fva "ov_voxelMeshTransparency_shr_setupClothVColor" 0.8;
        optionVar -fva "ov_voxelMeshTransparency_shr_setupClothVColor" 0.8;
    }

    // 法線を表示
    if (`optionVar -ex "ov_showNormals_shr_setupClothVColor"` == 0)
    {
        optionVar -iv "ov_showNormals_shr_setupClothVColor" 1;
    }

    // 元メッシュを非表示
    if (`optionVar -ex "ov_hideSourceMeshes_shr_setupClothVColor"` == 0)
    {
        optionVar -iv "ov_hideSourceMeshes_shr_setupClothVColor" 1;
    }
}

/////////////////////////////////////////////////
// ボクセルメッシュ用 一時マテリアル作成
/////////////////////////////////////////////////
global proc string shr_setupClothVColor_createTempMaterial()
{
    string $tempVoxelMat = "temp_voxel_mat";
    string $tempVoxelMatSG = $tempVoxelMat + "SG";

    if(`objExists $tempVoxelMat` == false)
    {
        // マテリアル作成
        shadingNode -asShader "lambert" -name $tempVoxelMat;

        if(`objExists $tempVoxelMatSG` == false)
        {
            // シェーディンググループ作成
            sets -renderable true -noSurfaceShader true -empty -name $tempVoxelMatSG;
        }

        connectAttr ($tempVoxelMat + ".outColor") ($tempVoxelMatSG + ".surfaceShader");
    }

    // カラーを設定
    float $color[] = `optionVar -q "ov_voxelMeshColor_shr_setupClothVColor"`;
    setAttr "temp_voxel_mat.color" -type double3 $color[0] $color[1] $color[2];

    // 透明度を設定
    float $transparency[] = `optionVar -q "ov_voxelMeshTransparency_shr_setupClothVColor"`;
    setAttr "temp_voxel_mat.transparency" -type double3 $transparency[0] $transparency[1] $transparency[2];

    return $tempVoxelMat;
}

/////////////////////////////////////////////////
// Houdini Asset Node を作成
/////////////////////////////////////////////////
global proc string shr_setupClothVColor_createHoudiniAsset(string $meshInputNodes[])
{
    // hda ノード作成
    string $hdaNode = houdiniEngine_loadAsset("C:/cygames/shrdev/shr/tools/in/ext/maya/share/hda/shr_setup_cloth_vcolor.hda", "Sop/shr_cloth_setup");

    setAttr ($hdaNode + ".syncWhenInputConnects") false;

    // 出力メッシュをグループで分割
    setAttr ($hdaNode + ".splitGeosByGroup") true;

    // グループのセットを作成しない
    setAttr ($hdaNode + ".outputGeometryGroups") false;

    // シェーディンググループを指定
    setAttr ($hdaNode + ".houdiniAssetParm_voxel_shading_group") -type "string" "temp_voxel_matSG";

    // 頂点カラーデバッグ表示を指定
    setAttr ($hdaNode + ".houdiniAssetParm_vertex_color_debug_view") `optionVar -q ov_vertexColorDebugView_shr_setupClothVColor`;

    // 表示メッシュを指定
    setAttr ($hdaNode + ".houdiniAssetParm_display_mesh") `optionVar -q ov_displayMesh_shr_setupClothVColor`;

    // Cloth Mesh インプットに入力
    houdiniEngine_setAssetInput(($hdaNode + ".input[0].inputNodeId"), $meshInputNodes);

    // Sync Asset
    // houdiniEngine_syncAssetOutput $hdaNode;

    // Auto Sync Output
    // setAttr ($hdaNode + ".autoSyncOutputs") true;

    return $hdaNode;
}

/////////////////////////////////////////////////
// Houdini Asset Node で生成されたメッシュを取得
/////////////////////////////////////////////////
global proc string[] shr_setupClothVColor_getGeneratedMeshes()
{
    // HDA ノード
    global string $gHdaNode_shr_setupClothVColor;

    string $generatedMeshes[] = `listRelatives -ad -pa -type "mesh" $gHdaNode_shr_setupClothVColor`;

    return $generatedMeshes;
}

/////////////////////////////////////////////////
// ボクセルメッシュか
/////////////////////////////////////////////////
global proc int shr_setupClothVColor_isVoxelMesh(string $node)
{
    return `gmatch $node "*temp_voxel_mesh*"`;
}

/////////////////////////////////////////////////
// ボクセルメッシュの頂点カラー表示をオフに
/////////////////////////////////////////////////
global proc shr_setupClothVColor_disableVoxelMeshVColors()
{
    string $generatedMeshes[] = shr_setupClothVColor_getGeneratedMeshes();

    string $elm;

    for($elm in $generatedMeshes)
    {
        // ボクセルメッシュの場合は頂点カラー表示をオフに
        if(shr_setupClothVColor_isVoxelMesh($elm))
        {
            setAttr ($elm + ".displayColors") false;
        }
    }
}

/////////////////////////////////////////////////
// ボクセルメッシュの頂点法線表示を変更
/////////////////////////////////////////////////
global proc shr_setupClothVColor_showNormalsCommand(int $showNormals)
{
    string $generatedMeshes[] = shr_setupClothVColor_getGeneratedMeshes();

    string $elm;

    for($elm in $generatedMeshes)
    {
        // ボクセルメッシュの場合は頂点法線表示を変更
        if(shr_setupClothVColor_isVoxelMesh($elm))
        {
            setAttr ($elm + ".normalType") 2;
            setAttr ($elm + ".displayNormal") $showNormals;
        }
    }
}

/////////////////////////////////////////////////
// Hide Source Meshes チェックボックスのコールバック
/////////////////////////////////////////////////
global proc shr_setupClothVColor_hideSourceMeshesCommand(int $hideSourceMeshes)
{
    global string $gSourceNodes_shr_setupClothVColor[];
    global int $gSourceNodesVisibility_shr_setupClothVColor[];

    int $index;

    string $elm;

    for($elm in $gSourceNodes_shr_setupClothVColor)
    {
        if(`objExists $elm` == false)
        {
            $index += 1;
            continue;
        }

        if($hideSourceMeshes)
        {
            setAttr ($elm + ".visibility") false;
        }
        else
        {
            if($gSourceNodesVisibility_shr_setupClothVColor[$index])
            {
                setAttr ($elm + ".visibility") 1;
            }
        }

        $index += 1;
    }
}

/////////////////////////////////////////////////
// 前回適用時のパラメータをカスタムアトリビュートから取得して適用
/////////////////////////////////////////////////
global proc shr_setupClothVColor_restoreParamsFromCustomAttributes()
{
    // HDA ノード
    global string $gHdaNode_shr_setupClothVColor;

    // ソースノード
    global string $gSourceNodes_shr_setupClothVColor[];

    string $sourceNode;

    for($sourceNode in $gSourceNodes_shr_setupClothVColor)
    {
        // 揺れマスクの長さ
        if(`attributeExists "shr_cloth_swayMaskLength" $sourceNode`)
        {
            setAttr ($gHdaNode_shr_setupClothVColor + ".houdiniAssetParm_sway_mask_length") `getAttr ($sourceNode + ".shr_cloth_swayMaskLength")`;
        }

        // 揺れマスクの長さ基準にケージメッシュを使用
        if(`attributeExists "shr_cloth_useCageMesh" $sourceNode`)
        {
            setAttr ($gHdaNode_shr_setupClothVColor + ".houdiniAssetParm_use_cage_mesh") `getAttr ($sourceNode + ".shr_cloth_useCageMesh")`;
        }

        // ピン留めメッシュ
        if(`attributeExists "shr_cloth_pinningMeshes" $sourceNode`)
        {
            string $pinningMeshes[] = `getAttr ($sourceNode + ".shr_cloth_pinningMeshes")`;

            string $existingPinningMeshes[];

            string $pinningMesh;

            for($pinningMesh in $pinningMeshes)
            {
                if(`objExists $pinningMesh`)
                {
                    $existingPinningMeshes[`size($existingPinningMeshes)`] = $pinningMesh;
                }
                else
                {
                    warning -n ($pinningMesh + " is not found");
                }
            }

            // Cloth Mesh インプットに入力
            houdiniEngine_setAssetInput(($gHdaNode_shr_setupClothVColor + ".input[1].inputNodeId"), $existingPinningMeshes);
        }

        // ピン留めの影響範囲
        if(`attributeExists "shr_cloth_pinInfuluenceRange" $sourceNode`)
        {
            setAttr ($gHdaNode_shr_setupClothVColor + ".houdiniAssetParm_pin_radius") `getAttr ($sourceNode + ".shr_cloth_pinInfuluenceRange")`;
        }

        // ピン留めのフォールオフ距離
        if(`attributeExists "shr_cloth_pinFalloffDistance" $sourceNode`)
        {
            setAttr ($gHdaNode_shr_setupClothVColor + ".houdiniAssetParm_pin_falloff_dist") `getAttr ($sourceNode + ".shr_cloth_pinFalloffDistance")`;
        }
    }
}

/////////////////////////////////////////////////
// 適用時のパラメータをカスタムアトリビュートに格納
/////////////////////////////////////////////////
global proc shr_setupClothVColor_storeParamsToCustomAttributes()
{
    // HDA ノード
    global string $gHdaNode_shr_setupClothVColor;

    // ソースノード
    global string $gSourceNodes_shr_setupClothVColor[];

    // 揺れマスクの長さ
    float $swayMaskLength = `getAttr ($gHdaNode_shr_setupClothVColor + ".houdiniAssetParm_sway_mask_length")`;

    // 揺れマスクの長さ基準にケージメッシュを使用
    int $useCageMesh = `getAttr ($gHdaNode_shr_setupClothVColor + ".houdiniAssetParm_use_cage_mesh")`;

    // ピン留めメッシュ
    string $pinningMeshes[] = houdiniEngine_getAssetInput(($gHdaNode_shr_setupClothVColor + ".input[1].inputNodeId"));

    // ピン留めの影響範囲
    float $pinInfluenceRange = `getAttr ($gHdaNode_shr_setupClothVColor + ".houdiniAssetParm_pin_radius")`;

    // ピン留めのフォールオフ距離
    float $pinFalloffDistance = `getAttr ($gHdaNode_shr_setupClothVColor + ".houdiniAssetParm_pin_falloff_dist")`;

    string $attrName;
    string $node;

    for($node in $gSourceNodes_shr_setupClothVColor)
    {
        $attrName = "shr_cloth_swayMaskLength";
        addAttr -ln $attrName -at "float" $node;
        setAttr ($node + "." +  $attrName) $swayMaskLength;

        $attrName = "shr_cloth_useCageMesh";
        addAttr -ln $attrName -at bool $node;
        setAttr ($node + "." +  $attrName) $useCageMesh;

        int $pinMeshesNum = `size($pinningMeshes)`;

        if($pinMeshesNum != 0)
        {
            $attrName = "shr_cloth_pinningMeshes";
            addAttr -ln $attrName -dt stringArray $node;

            string $valuesStr;

            string $pinningMesh;

            for($pinningMesh in $pinningMeshes)
            {
                $valuesStr += "\"" + $pinningMesh + "\" ";
            }

            string $evalStr = "setAttr " + $node + "." +  $attrName + " -type stringArray " + $pinMeshesNum + " " + $valuesStr;

            eval $evalStr;
        }

        $attrName = "shr_cloth_pinInfuluenceRange";
        addAttr -ln $attrName -at "float" $node;
        setAttr ($node + "." +  $attrName) $pinInfluenceRange;

        $attrName = "shr_cloth_pinFalloffDistance";
        addAttr -ln $attrName -at "float" $node;
        setAttr ($node + "." +  $attrName) $pinFalloffDistance;
    }
}

/////////////////////////////////////////////////
// 適用ボタンのコールバック
/////////////////////////////////////////////////
global proc shr_setupClothVColor_applyCommand()
{
    // HDA ノード
    global string $gHdaNode_shr_setupClothVColor;

    // リザルト頂点カラーの表示
    setAttr ($gHdaNode_shr_setupClothVColor + ".houdiniAssetParm_vertex_color_debug_view") 0;

    // リザルトメッシュのみ表示
    setAttr ($gHdaNode_shr_setupClothVColor + ".houdiniAssetParm_display_mesh") 0;

    // HDA から出力されたメッシュをベイクし再構築する
    string $resultNodes[] = shr_rebuildHdaOutputMeshes($gHdaNode_shr_setupClothVColor);

    // 適用時の設定を出力メッシュのカスタムアトリビュートに格納
    shr_setupClothVColor_storeParamsToCustomAttributes();

    // ウィンドウを削除
    deleteUI uWnd_shr_setupClothVColor;
}

/////////////////////////////////////////////////
// ウィンドウを閉じたときのコールバック
/////////////////////////////////////////////////
global proc shr_setupClothVColor_closeCommand()
{
    // ソースノード
    global string $gSourceNodes_shr_setupClothVColor[];

    // ソースノードのvisibility
    global int $gSourceNodesVisibility_shr_setupClothVColor[];

    // HDA ノード
    global string $gHdaNode_shr_setupClothVColor;

    if(`objExists $gHdaNode_shr_setupClothVColor`)
    {
        delete $gHdaNode_shr_setupClothVColor;
    }

    string $elm;

    int $index;

    select -clear;

    // ソースノードが残っていれば表示状態と選択を復元
    for($elm in $gSourceNodes_shr_setupClothVColor)
    {
        if(`objExists $elm`)
        {
            setAttr ($elm + ".visibility") $gSourceNodesVisibility_shr_setupClothVColor[$index];

            select -add $elm;
        }

        $index += 1;
    }

    // 一時マテリアルを削除
    shr_setupClothVColor_deleteTempMaterial;

    // グローバル変数を削除
    clear $gSourceNodes_shr_setupClothVColor;
    clear $gSourceNodesVisibility_shr_setupClothVColor;
}

/////////////////////////////////////////////////
// ボクセルメッシュ用 一時マテリアル削除
/////////////////////////////////////////////////
global proc shr_setupClothVColor_deleteTempMaterial()
{
    string $tempVoxelMat = "temp_voxel_mat";
    string $tempVoxelMatSG = $tempVoxelMat + "SG";

    if(`objExists $tempVoxelMat`)
    {
        delete $tempVoxelMat;

        if(`objExists $tempVoxelMatSG` == false)
        {
            delete $tempVoxelMatSG;
        }
    }
}

// NOTE:
// shr_setupClothVColor;